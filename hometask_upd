Задание: 1 (Serge I: 2002-09-30)
Найдите номер модели, скорость и размер жесткого диска для всех ПК стоимостью менее 500 дол. Вывести: model, speed и hd

SELECT model, speed, hd
FROM PC
WHERE price < 500;

Задание: 2 (Serge I: 2002-09-21)
Найдите производителей принтеров. Вывести: maker

SELECT DISTINCT maker 
FROM Product
WHERE type = 'Printer';

Задание: 3 (Serge I: 2002-09-30)
Найдите номер модели, объем памяти и размеры экранов ПК-блокнотов, цена которых превышает 1000 дол.

SELECT model, ram, screen
FROM Laptop
WHERE price > 1000;


Задание: 4 (Serge I: 2002-09-21)
Найдите все записи таблицы Printer для цветных принтеров.

SELECT * 
FROM Printer
WHERE color = 'y';

Задание: 5 (Serge I: 2002-09-30)
Найдите номер модели, скорость и размер жесткого диска ПК, имеющих 12x или 24x CD и цену менее 600 дол.

SELECT PC.model, PC.speed, PC.hd 
FROM PC 
WHERE (PC.cd = '12x' OR 
PC.cd = '24x') AND 
price < 600;

Задание: 6 (Serge I: 2002-10-28)
Для каждого производителя, выпускающего ПК-блокноты c объёмом жесткого диска не менее 10 Гбайт, найти скорости таких ПК-блокнотов. Вывод: производитель, скорость.

SELECT DISTINCT maker, speed
FROM Laptop JOIN 
 Product ON Laptop.model = Product.model
WHERE hd >= 10;

Задание: 7 (Serge I: 2002-11-02)
Найдите номера моделей и цены всех имеющихся в продаже продуктов (любого типа) производителя B (латинская буква).

SELECT PC.model, PC.price
FROM PC INNER JOIN   
     Product ON PC.model = Product.model
WHERE Product.maker = 'B'
UNION
SELECT Printer.model, Printer.price
FROM Printer INNER JOIN   
     Product ON Printer.model = Product.model
WHERE Product.maker = 'B'
UNION
SELECT Laptop.model, Laptop.price
FROM Laptop INNER JOIN   
     Product ON Laptop.model = Product.model
WHERE Product.maker = 'B';

Задание: 8 (Serge I: 2003-02-03)
Найдите производителя, выпускающего ПК, но не ПК-блокноты.

SELECT DISTINCT maker FROM Product
WHERE type = 'PC'
EXCEPT
SELECT DISTINCT maker FROM Product
WHERE type = 'Laptop';

Задание: 9 (Serge I: 2002-11-02)
Найдите производителей ПК с процессором не менее 450 Мгц. Вывести: Maker

SELECT DISTINCT maker 
FROM Product JOIN 
PC ON Product.model = PC.model
WHERE speed >= 450

Задание: 10 (Serge I: 2002-09-23)
Найдите модели принтеров, имеющих самую высокую цену. Вывести: model, price

SELECT DISTINCT model, price
FROM Printer
WHERE price = (SELECT MAX(price) 
 FROM Printer
 );
 
Задание: 11 (Serge I: 2002-11-02)
Найдите среднюю скорость ПК.

SELECT AVG(speed) AS Avg_Speed
FROM PC;

Задание: 12 (Serge I: 2002-11-02)
Найдите среднюю скорость ПК-блокнотов, цена которых превышает 1000 дол.

SELECT AVG(speed) AS Avg_Speed
FROM Laptop
WHERE price > 1000;


Задание: 13 (Serge I: 2002-11-02)
Найдите среднюю скорость ПК, выпущенных производителем A.

SELECT AVG(speed) AS Avg_Speed 
FROM PC JOIN 
Product ON PC.model = Product.model
WHERE maker = 'A';

Задание: 14 (Serge I: 2002-11-05)
Найдите класс, имя и страну для кораблей из таблицы Ships, имеющих не менее 10 орудий.

SELECT Classes.class, name, country 
FROM Ships JOIN
Classes ON Ships.class = Classes.class
WHERE numGuns >= 10;

Задание: 15 (Serge I: 2003-02-03)
Найдите размеры жестких дисков, совпадающих у двух и более PC. Вывести: HD

SELECT hd
FROM PC 
GROUP BY hd
HAVING (COUNT(hd) >= 2);

Задание: 16 (Serge I: 2003-02-03)
Найдите пары моделей PC, имеющих одинаковые скорость и RAM. В результате каждая пара указывается только один раз, т.е. (i,j), но не (j,i), 
Порядок вывода: модель с большим номером, модель с меньшим номером, скорость и RAM.

SELECT DISTINCT A.model AS model_1, B.model AS model_2, A.speed, A.ram
FROM PC AS A, PC B
WHERE A.speed = B.speed AND
A.ram = B.ram AND 
 A.model > B.model;
 
Задание: 17 (Serge I: 2003-02-03)
Найдите модели ПК-блокнотов, скорость которых меньше скорости каждого из ПК.
Вывести: type, model, speed

SELECT DISTINCT Product.type, Laptop.model, Laptop.speed
FROM Laptop, Product
WHERE Laptop.speed < ALL (SELECT PC.speed 
 FROM PC)
AND Product.type = 'Laptop';

Задание: 18 (Serge I: 2003-02-03)
Найдите производителей самых дешевых цветных принтеров. Вывести: maker, price

SELECT DISTINCT Product.maker, Printer.price
FROM Product
JOIN Printer on Product.model = Printer.model
WHERE Printer.color = 'y' and Printer.price = (select MIN(price) from Printer where color = 'y')

Задание: 19 (Serge I: 2003-02-13)
Для каждого производителя, имеющего модели в таблице Laptop, найдите средний размер экрана выпускаемых им ПК-блокнотов.
Вывести: maker, средний размер экрана.

Select maker, AVG(screen)as Avg_screen 
FROM Laptop join
 Product on Laptop.model =  Product.model 
GROUP BY maker;

Задание: 20 (Serge I: 2003-02-13)
Найдите производителей, выпускающих по меньшей мере три различных модели ПК. Вывести: Maker, число моделей ПК.

SELECT maker, COUNT(model) AS model
FROM Product
WHERE type = 'PC'
GROUP BY maker 
HAVING COUNT(model) >= 3;

Задание: 21 (Serge I: 2003-02-13)
Найдите максимальную цену ПК, выпускаемых каждым производителем, у которого есть модели в таблице PC.
Вывести: maker, максимальная цена.

SELECT maker, MAX(price) AS price
FROM Product JOIN
PC ON Product.model = PC.model
WHERE type = 'PC'
GROUP BY maker;

Задание: 22 (Serge I: 2003-02-13)
Для каждого значения скорости ПК, превышающего 600 МГц, определите среднюю цену ПК с такой же скоростью. Вывести: speed, средняя цена.

SELECT speed, AVG(price) as Avg_price 
FROM PC
WHERE speed > 600 
GROUP BY speed;

Задание: 23 (Serge I: 2003-02-14)
Найдите производителей, которые производили бы как ПК
со скоростью не менее 750 МГц, так и ПК-блокноты со скоростью не менее 750 МГц.
Вывести: Maker

SELECT DISTINCT maker 
FROM PC 
JOIN Product on PC.model = Product.model
where pc.speed >= 750
INTERSECT
SELECT DISTINCT maker 
FROM Laptop
JOIN Product on Laptop.model = Product.model
where Laptop.speed >= 750;

Задание: 24 (Serge I: 2003-02-03)
Перечислите номера моделей любых типов, имеющих самую высокую цену по всей имеющейся в базе данных продукции.

WITH result AS( 
SELECT DISTINCT model, price FROM laptop WHERE laptop.price = (SELECT MAX(price) FROM laptop)  
UNION 
SELECT DISTINCT model, price FROM pc WHERE pc.price = (SELECT MAX(price) FROM pc)  
UNION 
SELECT DISTINCT model, price FROM printer WHERE printer.price = (SELECT MAX(price) FROM printer)  
) 
SELECT model
FROM result
WHERE price >= (SELECT MAX(price) 
 FROM result);
 
Задание: 25 (Serge I: 2003-02-14)
Найдите производителей принтеров, которые производят ПК с наименьшим объемом RAM и с самым быстрым процессором среди всех ПК, имеющих наименьший объем RAM. 
Вывести: Maker

SELECT DISTINCT Product.maker FROM Product WHERE Product.type='Printer'  
INTERSECT 
SELECT DISTINCT Product.maker FROM Product 
JOIN PC ON PC.model = Product.model  
WHERE Product.type='PC' AND PC.ram=(SELECT MIN(ram) FROM PC)  
AND PC.speed = (SELECT MAX(speed) FROM (SELECT distinct speed FROM PC
WHERE PC.ram=(SELECT MIN(ram) FROM PC)) as result)

Задание: 26 (Serge I: 2003-02-14)
Найдите среднюю цену ПК и ПК-блокнотов, выпущенных производителем A (латинская буква). Вывести: одна общая средняя цена.

WITH result as (
SELECT AVG(price) AS a 
FROM Product JOIN 
PC ON PC.model = Product.model
UNION
SELECT AVG(price) AS b
FROM Product JOIN 
Laptop ON Laptop.model = Product.model)
SELECT AVG(result)

Задание: 27 (Serge I: 2003-02-03)
Найдите средний размер диска ПК каждого из тех производителей, которые выпускают и принтеры. Вывести: maker, средний размер HD.

SELECT maker, AVG(hd)
FROM Product JOIN 
PC on Product.model = PC.model   
WHERE maker IN(SELECT maker  
FROM Product 
WHERE type='Printer')  
GROUP BY maker

Задание: 28 (Serge I: 2012-05-04)
Используя таблицу Product, определить количество производителей, выпускающих по одной модели.

SELECT COUNT(maker) AS result FROM(SELECT maker
FROM Product 
GROUP BY maker
HAVING COUNT(model) = 1) AS Product

Задание: 29 (Serge I: 2003-02-14)
В предположении, что приход и расход денег на каждом пункте приема фиксируется не чаще одного раза в день [т.е. первичный ключ (пункт, дата)], написать запрос с выходными данными (пункт, дата, приход, расход). Использовать таблицы Income_o и Outcome_o.

SELECT i.point, i.date, inc, out 
FROM income_o i 
LEFT JOIN outcome_o o on i.point = o.point and i.date = o.date
UNION
SELECT o.point, o.date, inc, out
FROM income_o i 
RIGHT JOIN outcome_o o on i.point = o.point and i.date = o.date

Задание: 30 (Serge I: 2003-02-14)
В предположении, что приход и расход денег на каждом пункте приема фиксируется произвольное число раз (первичным ключом в таблицах является столбец code), требуется получить таблицу, в которой каждому пункту за каждую дату выполнения операций будет соответствовать одна строка.
Вывод: point, date, суммарный расход пункта за день (out), суммарный приход пункта за день (inc). Отсутствующие значения считать неопределенными (NULL).

SELECT point, date, SUM(sum_out), SUM(sum_inc)
FROM( select point, date, SUM(inc) as sum_inc, null as sum_out 
FROM Income 
GROUP BY point, date
UNION
SELECT point, date, null as sum_inc, SUM(out) as sum_out 
FROM Outcome 
GROUP BY point, date ) as t
GROUP BY point, date 
ORDER BY point

Задание 31. Для классов кораблей, калибр орудий которых не менее 16 дюймов, укажите класс и страну.

SELECT class, country 
FROM classes 
WHERE bore >= '16'

Задание 32. Одной из характеристик корабля является половина куба калибра его главных орудий (mw). С точностью до 2 десятичных знаков определите среднее значение mw для кораблей каждой страны, у которой есть корабли в базе данных.

SELECT country, cast(avg((power(bore,3)/2)) as numeric(6,2)) as weight 
FROM (select country, classes.class, bore, name 
FROM classes 
LEFT JOIN ships ON classes.class=ships.class  
UNION ALL
SELECT distinct country, class, bore, ship 
FROM classes t1 
LEFT JOIN outcomes t2 ON t1.class=t2.ship  
WHERE ship=class and ship not in (select name from ships) ) a  
WHERE name!='null' 
GROUP BY country

Задание 33. Укажите корабли, потопленные в сражениях в Северной Атлантике (North Atlantic). Вывод: ship.

SELECT ship 
FROM outcomes,battles 
WHERE result= 'sunk' and battle = 'North Atlantic' 
GROUP BY ship 

Задание: 34 (Serge I: 2002-11-04)
По Вашингтонскому международному договору от начала 1922 г. запрещалось строить линейные корабли водоизмещением более 35 тыс.тонн. Укажите корабли, нарушившие этот договор (учитывать только корабли c известным годом спуска на воду). Вывести названия кораблей.

SELECT name 
FROM classes,ships 
WHERE launched >=1922 and displacement>35000 and type='bb' and ships.class = classes.class

Задание: 35 (qwrqwr: 2012-11-23)
В таблице Product найти модели, которые состоят только из цифр или только из латинских букв (A-Z, без учета регистра).
Вывод: номер модели, тип модели.

SELECT name 
FROM classes,ships 
WHERE launched >=1922 and displacement>35000 and type='bb' and ships.class = classes.class

Задание: 36 (Serge I: 2003-02-17)
Перечислите названия головных кораблей, имеющихся в базе данных (учесть корабли в Outcomes).

SELECT distinct c.class 
FROM classes c 
JOIN outcomes o ON c.class = o.ship
UNION
SELECT distinct c.class 
FROM classes c join ships s ON c.class = s.class 
WHERE s.class = s.name

Задание: 37 (Serge I: 2003-02-17)
Найдите классы, в которые входит только один корабль из базы данных (учесть также корабли в Outcomes).

SELECT class FROM(select class, name FROM ships
UNION
SELECT class, ship as name 
FROM outcomes 
JOIN classes ON classes.class = outcomes.ship) as A
GROUP BY class 
HAVING count(A.name)=1

Задание: 38 (Serge I: 2003-02-19)
Найдите страны, имевшие когда-либо классы обычных боевых кораблей ('bb') и имевшие когда-либо классы крейсеров ('bc').

SELECT country FROM classes where type = 'bb'
INTERSECT
SELECT country FROM classes where type = 'bc'

Задание: 39 (Serge I: 2003-02-14)
Найдите корабли, `сохранившиеся для будущих сражений`; т.е. выведенные из строя в одной битве (damaged), они участвовали в другой, произошедшей позже.

SELECT distinct o.ship 
FROM outcomes o join battles b ON o.battle = b.name 
WHERE o.result = 'damaged' AND EXISTS (SELECT battles.date
FROM battles join outcomes ON outcomes.battle = battles.name
WHERE battles.date > b.date and outcomes.ship = o.ship)

Задание: 40 (Serge I: 2012-04-20)
Найти производителей, которые выпускают более одной модели, при этом все выпускаемые производителем модели являются продуктами одного типа.
Вывести: maker, type
SELECT maker, type 
FROM product
WHERE maker in (SELECT maker FROM
(SELECT maker, type FROM Product GROUP BY maker, type) Alias
GROUP BY maker having count(maker) = 1) GROUP BY maker, type HAVING count(type)>1

Задание: 41 (Serge I: 2019-05-31)
Для каждого производителя, у которого присутствуют модели хотя бы в одной из таблиц PC, Laptop или Printer,
определить максимальную цену на его продукцию.
Вывод: имя производителя, если среди цен на продукцию данного производителя присутствует NULL, то выводить для этого производителя NULL,
иначе максимальную цену.

WITH D as
(SELECT model, price FROM PC
UNION
SELECT model, price FROM Laptop
UNION
SELECT model, price FROM Printer)
SELECT distinct P.maker,
CASE WHEN MAX(CASE WHEN D.price IS NULL THEN 1 ELSE 0 END) = 0 THEN
max(D.price) end
FROM Product P
RIGHT JOIN D ON P.model=D.model
GROUP BY P.maker

Задание: 42 (Serge I: 2002-11-05)
Найдите названия кораблей, потопленных в сражениях, и название сражения, в котором они были потоплены.
SELECT 
	ship, battle
FROM Outcomes
WHERE result = 'sunk'

Задание: 43 (qwrqwr: 2011-10-28)
Укажите сражения, которые произошли в годы, не совпадающие ни с одним из годов спуска кораблей на воду.
SELECT name 
FROM battles 
WHERE DATEPART(yy, date) not in (select DATEPART(yy, date)  
FROM battles 
JOIN ships on DATEPART(yy, date)=launched)

Задание: 44 (Serge I: 2002-12-04)
Найдите названия всех кораблей в базе данных, начинающихся с буквы R.
SELECT name 
FROM ships 
WHERE name like 'R%'   
UNION   
SELECT name 
FROM battles 
WHERE name like 'R%'   
UNION   
SELECT ship 
FROM outcomes 
WHERE ship like 'R%'

Задание: 45 (Serge I: 2002-12-04)
Найдите названия всех кораблей в базе данных, состоящие из трех и более слов (например, King George V).
Считать, что слова в названиях разделяются единичными пробелами, и нет концевых пробелов.

SELECT name 
FROM ships 
WHERE name like '% % %'  
UNION   
SELECT ship 
FROM outcomes 
WHERE ship like '% % %'  

Задание: 46 (Serge I: 2003-02-14)
Для каждого корабля, участвовавшего в сражении при Гвадалканале (Guadalcanal), вывести название, водоизмещение и число орудий.

SELECT name as n, displacement as d, numguns as ng 
FROM ships 
INNER JOIN classes ON ships.class=classes.class 
WHERE name in (SELECT ship FROM outcomes WHERE battle = 'Guadalcanal')   
UNION 
SELECT ship as n, displacement as d, numguns as ng 
FROM outcomes
INNER JOIN classes ON outcomes.ship=classes.class 
WHERE battle = 'Guadalcanal' and ship not in (select name from ships)   
UNION  
SELECT ship as n, null as d, null as ng 
FROM outcomes 
WHERE battle = 'Guadalcanal' and ship not in (select name from ships) and ship not in  (select class from classes)     

Задание: 47 (Serge I: 2019-06-07)
Определить страны, которые потеряли в сражениях все свои корабли.
WITH out AS (SELECT *
FROM outcomes JOIN (SELECT ships.name s_name, classes.class s_class, classes.country s_country
FROM ships FULL JOIN classes
ON ships.class = classes.class
) u
ON outcomes.ship=u.s_class
UNION
SELECT *
FROM outcomes JOIN (SELECT ships.name s_name, classes.class s_class, classes.country s_country
FROM ships FULL JOIN classes
ON ships.class = classes.class
) u
ON outcomes.ship=u.s_name)
SELECT fin.country
FROM (
SELECT DISTINCT t.country, COUNT(t.name) AS num_ships
FROM (
SELECT distinct c.country, s.name
FROM classes c
INNER JOIN Ships s ON s.class= c.class
UNION
SELECT distinct c.country, o.ship
FROM classes c
INNER JOIN Outcomes o on o.ship= c.class) t
GROUP BY t.country
INTERSECT
SELECT out.s_country, COUNT(out.ship) AS num_ships
FROM out
WHERE out.result='sunk'
GROUP BY out.s_country) fin   

Задание: 48 (Serge I: 2003-02-16)
Найдите классы кораблей, в которых хотя бы один корабль был потоплен в сражении.

SELECT class
FROM classes t1 
LEFT JOIN outcomes t2 on t1.class=t2.ship 
WHERE result='sunk'
UNION
SELECT class
FROM ships 
LEFT JOIN outcomes on ships.name=outcomes.ship 
WHERE result='sunk'

Задание 49. Найдите названия кораблей с орудиями калибра 16 дюймов (учесть корабли из таблицы Outcomes). Решение:

SELECT s.name 
FROM ships s 
JOIN classes c ON s.name=c.class OR s.class = c.class WHERE c.bore = 16
UNION
SELECT o.ship FROM outcomes o JOIN classes c ON o.ship=c.class WHERE c.bore = 16

50
Найдите сражения, в которых участвовали корабли класса Kongo из таблицы Ships. Решение:
SELECT DISTINCT o.battle
FROM ships s 
JOIN outcomes o ON s.name = o.ship WHERE s.class = 'kongo'

51
Найдите названия кораблей, имеющих наибольшее число орудий среди всех имеющихся кораблей такого же водоизмещения (учесть корабли из таблицы Outcomes). Решение:

SELECT NAME 
FROM
(
SELECT name as NAME, displacement, numguns 
FROM ships 
INNER JOIN classes ON ships.class = classes.class 
UNION 
SELECT ship as NAME, displacement, numguns 
FROM outcomes 
INNER JOIN classes ON outcomes.ship= classes.class) as d1 
INNER JOIN (SELECT displacement, max(numGuns) as numguns 
FROM
( 
SELECT displacement, numguns 
FROM ships 
INNER JOIN classes ON ships.class = classes.class 
UNION 
SELECT displacement, numguns 
FROM outcomes 
INNER JOIN classes ON outcomes.ship= classes.class) as f 
GROUP BY displacement) as d2 ON d1.displacement=d2.displacement AND d1.numguns =d2.numguns

52
Определить названия всех кораблей из таблицы Ships, которые могут быть линейным японским кораблем, имеющим число главных орудий не менее девяти, калибр орудий менее 19 дюймов и водоизмещение не более 65 тыс.тонн Решение:

SELECT s.name as NAME
FROM ships s 
JOIN classes c ON s.class = c.class WHERE country = 'japan' AND (numGuns >= '9' OR numGuns is null) AND (bore < '19' or bore is null) AND (displacement <= '65000' OR displacement is null) AND type='bb'

53
Определите среднее число орудий для классов линейных кораблей. Получить результат с точностью до 2-х десятичных знаков. Решение:

SELECT CAST(AVG(numguns*1.0) AS NUMERIC(6,2)) AS Avg_nmg 
FROM classes 
WHERE type = 'bb'

54
С точностью до 2-х десятичных знаков определите среднее число орудий всех линейных кораблей (учесть корабли из таблицы Outcomes). Решение:

SELECT CAST(AVG(numguns*1.0) AS NUMERIC(6,2)) as AVG_nmg 
FROM (SELECT ship, numguns, type FROM Outcomes 
JOIN classes ON ship = class
UNION
SELECT name, numguns, type 
FROM ships s 
JOIN classes c ON c.class = s.class) as x 
WHERE type = 'bb'

55
Для каждого класса определите год, когда был спущен на воду первый корабль этого класса. Если год спуска на воду головного корабля неизвестен, определите минимальный год спуска на воду кораблей этого класса. Вывести: класс, год. Решение:

SELECT c.class, min(s.launched) 
FROM classes c 
LEFT JOIN ships s ON c.class = s.class 
GROUP BY c.class

56
Для каждого класса определите число кораблей этого класса, потопленных в сражениях. Вывести: класс и число потопленных кораблей. Решение:

SELECT c.class, COUNT(s.ship)
FROM classes c
LEFT JOIN (SELECT o.ship, sh.class
FROM outcomes o
LEFT JOIN ships sh ON sh.name = o.ship
WHERE o.result = 'sunk') AS s ON s.class = c.class OR s.ship = c.class
GROUP BY c.class

57
Для классов, имеющих потери в виде потопленных кораблей и не менее 3 кораблей в базе данных, вывести имя класса и число потопленных кораблей. Решение:

SELECT class, COUNT(ship) count_sunked
FROM (SELECT name, class FROM ships
      UNION
      SELECT ship, ship FROM outcomes) t
LEFT JOIN outcomes ON name = ship AND result = 'sunk'
GROUP BY class
HAVING COUNT(ship) > 0 AND COUNT(*) > 2;

58
Для каждого типа продукции и каждого производителя из таблицы Product c точностью до двух десятичных знаков найти процентное отношение числа моделей данного типа данного производителя к общему числу моделей этого производителя. Вывод: maker, type, процентное отношение числа моделей данного типа к общему числу моделей производителя Решение:

SELECT m, t,
CAST(100.0*cc/cc1 AS NUMERIC(5,2))
FROM
(SELECT m, t, sum(c) cc from
(SELECT DISTINCT maker m, 'PC' t, 0 c FROM product
UNION ALL
SELECT DISTINCT maker, 'Laptop', 0 FROM product
UNION ALL
SELECT DISTINCT maker, 'Printer', 0 FROM product
UNION ALL
SELECT maker, type, count(*) FROM product
GROUP BY maker, type) as tt
GROUP BY m, t) tt1
JOIN (
SELECT maker, count(*) cc1 FROM product GROUP BY maker
) tt2

59
Посчитать остаток денежных средств на каждом пункте приема для базы данных с отчетностью не чаще одного раза в день. Вывод: пункт, остаток. Решение:

SELECT c1, c2-
(CASE
WHEN o2 is null THEN 0
ELSE o2
END)
FROM
(SELECT point c1, sum(inc) c2 FROM income_o
GROUP BY point) as t1
LEFT JOIN
(SELECT point o1, sum(out) o2 FROM outcome_o
GROUP BY point) as t2
ON c1=o1

60
Посчитать остаток денежных средств на начало дня 15/04/01 на каждом пункте приема для базы данных с отчетностью не чаще одного раза в день. Вывод: пункт, остаток. Замечание. Не учитывать пункты, информации о которых нет до указанной даты. Решение:

SELECT c1, c2-
(CASE
WHEN o2 is null THEN 0
ELSE o2
END)
FROM
(SELECT point c1, sum(inc) c2 FROM income_o
WHERE date<'2001-04-15'
GROUP BY point) as t1
LEFT JOIN
(SELECT point o1, sum(out) o2 FROM outcome_o
WHERE date<'2001-04-15'
GROUP BY point) as t2
ON c1=o1

61
Посчитать остаток денежных средств на всех пунктах приема для базы данных с отчетностью не чаще одного раза в день. Решение:

SELECT sum(i) FROM
(SELECT point, SUM(inc) as i FROM
income_o
GROUP BY point
UNION
SELECT point, -sum(out) as i FROM
outcome_o
GROUP BY point
) as t

62
Посчитать остаток денежных средств на всех пунктах приема на начало дня 15/04/01 для базы данных с отчетностью не чаще одного раза в день. Решение:

SELECT
(SELECT sum(inc) FROM Income_o WHERE date<'2001-04-15')
-
(SELECT sum(out) FROM Outcome_o WHERE date<'2001-04-15')
AS remain

63
Определить имена разных пассажиров, когда-либо летевших на одном и том же месте более одного раза. Решение:

SELECT name FROM Passenger
WHERE ID_psg in
(SELECT ID_psg FROM Pass_in_trip
GROUP BY place, ID_psg
HAVING count(*)>1)

64
Используя таблицы Income и Outcome, для каждого пункта приема определить дни, когда был приход, но не было расхода и наоборот. Вывод: пункт, дата, тип операции (inc/out), денежная сумма за день. Решение:

SELECT i1.point, i1.date, 'inc', sum(inc) FROM Income,
(SELECT point, date FROM Income
EXCEPT
SELECT Income.point, Income.date FROM Income
JOIN Outcome ON (Income.point=Outcome.point) AND
(Income.date=Outcome.date)
) AS i1
WHERE i1.point=Income.point AND i1.date=Income.date
GROUP BY i1.point, i1.date
UNION
SELECT o1.point, o1.date, 'out', sum(out) FROM Outcome,
(SELECT point, date FROM Outcome
EXCEPT
SELECT Income.point, Income.date FROM Income
JOIN Outcome ON (Income.point=Outcome.point) AND
(Income.date=Outcome.date)
) AS o1
WHERE o1.point=Outcome.point AND o1.date=Outcome.date
GROUP BY o1.point, o1.date

65
Пронумеровать уникальные пары {maker, type} из Product, упорядочив их следующим образом: имя производителя (maker) по возрастанию; тип продукта (type) в порядке PC, Laptop, Printer. Если некий производитель выпускает несколько типов продукции, то выводить его имя только в первой строке; остальные строки для ЭТОГО производителя должны содержать пустую строку символов (''). Решение:

SELECT row_number() over(ORDER BY maker,s),t, type FROM
(SELECT maker,type,
CASE
WHEN type='PC'
THEN 0
WHEN type='Laptop'
THEN 1
ELSE 2
END AS s,
CASE
WHEN type='Laptop' AND (maker in (SELECT maker FROM Product WHERE
type='PC'))
THEN ''
WHEN type='Printer' AND ((maker in (SELECT maker FROM Product WHERE
type='PC')) OR (maker in (SELECT maker FROM Product WHERE
type='Laptop')))
THEN ''
ELSE maker
END AS t
FROM Product
GROUP BY maker,type) AS t1
ORDER BY maker, s

66
Для всех дней в интервале с 01/04/2003 по 07/04/2003 определить число рейсов из Rostov. Вывод: дата, количество рейсов Решение:

SELECT date, max(c) FROM
(SELECT date,count(*) AS c FROM Trip,
(SELECT trip_no,date FROM Pass_in_trip WHERE date>='2003-04-01' AND date<='2003-04-07' GROUP BY trip_no, date) AS t1
WHERE Trip.trip_no=t1.trip_no AND town_from='Rostov'
GROUP BY date
UNION ALL
SELECT '2003-04-01',0
UNION ALL
SELECT '2003-04-02',0
UNION ALL
SELECT '2003-04-03',0
UNION ALL
SELECT '2003-04-04',0
UNION ALL
SELECT '2003-04-05',0
UNION ALL
SELECT '2003-04-06',0
UNION ALL
SELECT '2003-04-07',0) AS t2
GROUP BY date

67
Найти количество маршрутов, которые обслуживаются наибольшим числом рейсов. Замечания. 1) A - B и B - A считать РАЗНЫМИ маршрутами. 2) Использовать только таблицу Trip Решение:

SELECT count(*) FROM
(SELECT TOP 1 WITH TIES count(*) c, town_from, town_to FROM trip
GROUP BY town_from, town_to
ORDER BY c desc) as t

68
Найти количество маршрутов, которые обслуживаются наибольшим числом рейсов. Замечания.1) A - B и B - A считать ОДНИМ И ТЕМ ЖЕ маршрутом. 2) Использовать только таблицу Trip Решение:

SELECT count(*) as Count FROM (
SELECT TOP 1 WITH TIES sum(c) cc, c1, c2 FROM (
SELECT count(*) c, town_from c1, town_to c2 FROM trip
WHERE town_from>=town_to
GROUP BY town_from, town_to
UNION ALL
SELECT count(*) c,town_to, town_from FROM trip
WHERE town_to>town_from
GROUP BY town_from, town_to
) as t
GROUP BY c1,c2
ORDER BY cc DESC
) as tt

69
По таблицам Income и Outcome для каждого пункта приема найти остатки денежных средств на конец каждого дня, в который выполнялись операции по приходу и/или расходу на данном пункте. Учесть при этом, что деньги не изымаются, а остатки/задолженность переходят на следующий день. Вывод: пункт приема, день в формате "dd/mm/yyyy", остатки/задолженность на конец этого дня. Решение:

with q as (
  SELECT
    isnull(i.point, o.point) point
    , isnull(i.date, o.date) date
    , coalesce(sum(i.inc), 0) - coalesce(sum(o.out), 0) balance
    FROM income i
    FULL JOIN outcome o
      ON i.point=o.point AND i.date=o.date AND i.code=o.code
    GROUP BY isnull(i.point, o.point), isnull(i.date, o.date)
)
 SELECT
  point
    -- 103 means format "dd/mm/yyyy"
  , convert(varchar, date, 103) day
  , sum(balance) over(partition by point order by date RANGE UNBOUNDED PRECEDING) as rem
  FROM q
ORDER BY point,date

70
Укажите сражения, в которых участвовало по меньшей мере три корабля одной и той же страны. Решение:

SELECT DISTINCT o.battle
FROM outcomes o
LEFT JOIN ships s ON s.name = o.ship
LEFT JOIN classes c ON o.ship = c.class OR s.class = c.class
WHERE c.country IS NOT NULL
GROUP BY c.country, o.battle
HAVING COUNT(o.ship) >= 3

71
Найти тех производителей ПК, все модели ПК которых имеются в таблице PC. Решение:

SELECT p.maker
FROM product p
LEFT JOIN pc ON pc.model = p.model
WHERE p.type = 'PC'
GROUP BY p.maker
HAVING COUNT(p.model) = COUNT(pc.model)

72
Среди тех, кто пользуется услугами только какой-нибудь одной компании, определить имена разных пассажиров, летавших чаще других. Вывести: имя пассажира и число полетов. Решение:

SELECT TOP 1 WITH TIES name, c3 FROM passenger
JOIN
(SELECT c1, max(c3) c3 FROM
(
SELECT pass_in_trip.ID_psg c1, Trip.ID_comp c2, count(*) c3 FROM pass_in_trip
JOIN trip ON trip.trip_no=pass_in_trip.trip_no
GROUP BY pass_in_trip.ID_psg, Trip.ID_comp
) as t
group by c1
HAVING count(*)=1) as tt
ON ID_psg=c1
ORDER BY c3 DESC

73
Для каждой страны определить сражения, в которых не участвовали корабли данной страны. Вывод: страна, сражение Решение:

SELECT c.country, b.name
FROM Classes c, Battles b
EXCEPT
SELECT c.country, o.battle
FROM Outcomes o
LEFT JOIN ships s ON o.ship=s.name
LEFT JOIN Classes c ON o.ship=c.class OR s.class=c.class
WHERE c.country is not null
GROUP BY c.country, o.battle

74
Вывести все классы кораблей России (Russia). Если в базе данных нет классов кораблей России, вывести классы для всех имеющихся в БД стран. Вывод: страна, класс Решение:

SELECT c.country, c.class
FROM classes c
WHERE UPPER(c.country) = 'RUSSIA' AND EXISTS (
SELECT c.country, c.class
FROM classes c
WHERE UPPER(c.country) = 'RUSSIA' )
UNION ALL
SELECT c.country, c.class
FROM classes c
WHERE NOT EXISTS (SELECT c.country, c.class
FROM classes c
WHERE UPPER(c.country) = 'RUSSIA' )

75
Для тех производителей, у которых есть продукты с известной ценой хотя бы в одной из таблиц Laptop, PC, Printer найти максимальные цены на каждый из типов продукции. Вывод: maker, максимальная цена на ноутбуки, максимальная цена на ПК, максимальная цена на принтеры. Для отсутствующих продуктов/цен использовать NULL. Решение:

SELECT shipname,launched,batname
FROM
(SELECT s.name as shipname,launched,b.name as batname,
row_number() over (partition by s.name order by "date") as num
FROM ships s,battles b
WHERE to_char("date",'yyyy')>=launched
AND launched is not null)
WHERE num = 1
UNION
(
SELECT name,launched,(SELECT name FROM battles
WHERE "date" = (SELECT MAX("date") FROM battles)) as batname
FROM ships
WHERE launched is null
)

76
Определить время, проведенное в полетах, для пассажиров, летавших всегда на разных местах. Вывод: имя пассажира, время в минутах. Решение:

with pf as(
  SELECT id_psg, count(*) as place_count
  FROM pass_in_trip
  GROUP BY id_psg, place
),
pt as(
  SELECT
    pt.id_psg, pt.trip_no
    , ps.name
    , time_out, time_in
    , CASE when time_out >= time_in
        then time_in-time_out + 1440
        else time_in-time_out
    end as time
  FROM pass_in_trip pt
  JOIN passenger ps ON ps.id_psg=pt.id_psg
  JOIN (
    SELECT
      datepart(hh, time_out)*60 + datepart(mi, time_out) time_out
      , datepart(hh, time_in)*60 + datepart(mi, time_in) time_in
      , trip_no
    FROM trip t
  ) as t ON t.trip_no=pt.trip_no
  WHERE 1=ALL(select place_count FROM pf WHERE pf.id_psg=pt.id_psg)
)
SELECT
  name, sum(time) fly_time
FROM pt
GROUP BY id_psg, name

77
Определить дни, когда было выполнено максимальное число рейсов из Ростова ('Rostov'). Вывод: число рейсов, дата. Решение:

SELECT TOP 1 WITH TIES * FROM
	(SELECT
		COUNT(distinct(pt.trip_no)) qty, pt.date
	FROM
		Trip t, Pass_in_trip pt
	WHERE t.trip_no=pt.trip_no AND t.town_from = 'Rostov'
	GROUP BY pt.date) t1
ORDER BY t1.qty DESC

78
Для каждого сражения определить первый и последний день месяца,в котором оно состоялось. Вывод: сражение, первый день месяца, последний день месяца. Замечание: даты представить без времени в формате "yyyy-mm-dd". Решение:

SELECT name, 
REPLACE(CONVERT(CHAR(12), 
DATEADD(m, DATEDIFF(m,0,date),0), 102),'.','-') AS first_day,
             REPLACE(CONVERT(CHAR(12), DATEADD(s,-1,DATEADD(m, DATEDIFF(m,0,date)+1,0)), 102),'.','-') AS last_day
FROM Battles

79
Определить пассажиров, которые больше других времени провели в полетах. Вывод: имя пассажира, общее время в минутах, проведенное в полетах Решение:

SELECT Passenger.name, A.minutes
FROM (SELECT P.ID_psg,
      SUM((DATEDIFF(minute, time_out, time_in) + 1440)%1440) AS minutes,
      MAX(SUM((DATEDIFF(minute, time_out, time_in) + 1440)%1440)) OVER() AS MaxMinutes
      FROM Pass_in_trip P JOIN
       Trip AS T ON P.trip_no = T.trip_no
      GROUP BY P.ID_psg
      ) AS A JOIN
 Passenger ON Passenger.ID_psg = A.ID_psg
WHERE A.minutes = A.MaxMinutes

80
Найти производителей любой компьютерной техники, у которых нет моделей ПК, не представленных в таблице PC. Решение:

SELECT DISTINCT maker
FROM product
WHERE maker NOT IN (
SELECT maker
FROM product
WHERE type='PC' AND model NOT IN (
SELECT model
FROM PC));

Из таблицы Outcome получить все записи за тот месяц (месяцы), с учетом года, в котором суммарное значение расхода (out) было максимальным. Решение:

SELECT O.*
FROM outcome O
INNER JOIN
(
SELECT TOP 1 WITH TIES YEAR(date) AS Y, MONTH(date) AS M, SUM(out) AS ALL_TOTAL
FROM outcome
GROUP BY YEAR(date), MONTH(date)
ORDER BY ALL_TOTAL DESC
) R ON YEAR(O.date) = R.Y AND MONTH(O.date) = R.M

82
В наборе записей из таблицы PC, отсортированном по столбцу code (по возрастанию) найти среднее значение цены для каждой шестерки подряд идущих ПК. Вывод: значение code, которое является первым в наборе из шести строк, среднее значение цены в наборе. Решение:

WITH CTE(code,price,number)
AS
(
SELECT PC.code,PC.price, number= ROW_NUMBER() OVER (ORDER BY PC.code)
FROM PC
)
SELECT CTE.code, AVG(C.price)
FROM CTE
JOIN CTE C ON (C.number-CTE.number)<6 AND (C.number-CTE.number)> =0
GROUP BY CTE.number,CTE.code
HAVING COUNT(CTE.number)=6

83
Определить названия всех кораблей из таблицы Ships, которые удовлетворяют, по крайней мере, комбинации любых четырёх критериев из следующего списка: numGuns = 8 bore = 15 displacement = 32000 type = bb launched = 1915 class=Kongo country=USA Решение:

SELECT name as NAME
FROM Ships AS s JOIN Classes AS cl1 ON s.class = cl1.class
WHERE
CASE WHEN numGuns = 8 THEN 1 ELSE 0 END +
CASE WHEN bore = 15 THEN 1 ELSE 0 END +
CASE WHEN displacement = 32000 THEN 1 ELSE 0 END +
CASE WHEN type = 'bb' THEN 1 ELSE 0 END +
CASE WHEN launched = 1915 THEN 1 ELSE 0 END +
CASE WHEN s.class = 'Kongo' THEN 1 ELSE 0 END +
CASE WHEN country = 'USA' THEN 1 ELSE 0 END > = 4;

84
Для каждой компании подсчитать количество перевезенных пассажиров (если они были в этом месяце) по декадам апреля 2003. При этом учитывать только дату вылета. Вывод: название компании, количество пассажиров за каждую декаду Решение:

SELECT C.name, A.N_1_10, A.N_11_21, A.N_21_30
FROM (SELECT T.ID_comp,
       SUM(CASE WHEN DAY(P.date) < 11 THEN 1 ELSE 0 END) AS N_1_10,
       SUM(CASE WHEN (DAY(P.date) > 10 AND DAY(P.date) < 21) THEN 1 ELSE 0 END) AS N_11_21,
       SUM(CASE WHEN DAY(P.date) > 20 THEN 1 ELSE 0 END) AS N_21_30
      FROM Trip AS T JOIN
       Pass_in_trip AS P ON T.trip_no = P.trip_no AND CONVERT(char(6), P.date, 112) = '200304'
      GROUP BY T.ID_comp
      ) AS A JOIN
 Company AS C ON A.ID_comp = C.ID_comp

85
Найти производителей, которые выпускают только принтеры или только PC. При этом искомые производители PC должны выпускать не менее 3 моделей. Решение:

SELECT maker FROM product
GROUP BY maker
HAVING count(distinct type) = 1 AND
(min(type) = 'printer' OR
(min(type) = 'pc' AND count(model) >= 3))

86
Для каждого производителя перечислить в алфавитном порядке с разделителем "/" все типы выпускаемой им продукции. Вывод: maker, список типов продукции Решение:

SELECT maker,
CASE count(distinct type) when 2 then MIN(type) + '/' + MAX(type)
when 1 then MAX(type)
when 3 then 'Laptop/PC/Printer' END
FROM Product
GROUP BY maker

87
Считая, что пункт самого первого вылета пассажира является местом жительства, найти не москвичей, которые прилетали в Москву более одного раза. Вывод: имя пассажира, количество полетов в Москву Решение:

SELECT DISTINCT name, COUNT(town_to) Qty
FROM Trip tr JOIN Pass_in_trip pit ON tr.trip_no = pit.trip_no JOIN
         Passenger psg ON pit.ID_psg = psg.ID_psg
WHERE town_to = 'Moscow' AND pit.ID_psg NOT IN(SELECT DISTINCT ID_psg
FROM Trip tr JOIN Pass_in_trip pit ON tr.trip_no = pit.trip_no
WHERE date+time_out = (SELECT MIN (date+time_out)
                       FROM Trip tr1 JOIN Pass_in_trip pit1 ON tr1.trip_no = pit1.trip_no
                       WHERE pit.ID_psg = pit1.ID_psg)
AND town_from = 'Moscow')
GROUP BY pit.ID_psg, name
HAVING COUNT(town_to) > 1

88
29)Среди тех, кто пользуется услугами только одной компании, определить имена разных пассажиров, летавших чаще других. Вывести: имя пассажира, число полетов и название компании. Решение:

SELECT
 (SELECT name FROM Passenger WHERE ID_psg = B.ID_psg) AS name,
 B.trip_Qty,
 (SELECT name FROM Company WHERE ID_comp = B.ID_comp) AS Company
FROM (SELECT P.ID_psg, MIN(T.ID_comp) AS ID_comp, COUNT(*) AS trip_Qty, MAX(COUNT(*)) OVER() AS Max_Qty
      FROM Pass_in_trip AS P JOIN
       Trip AS T ON P.trip_no = T.trip_no
      GROUP BY P.ID_psg
      HAVING MIN(T.ID_comp) = MAX(T.ID_comp)
      ) AS B
WHERE B.trip_Qty = B.Max_Qty;

89
Найти производителей, у которых больше всего моделей в таблице Product, а также тех, у которых меньше всего моделей. Вывод: maker, число моделей Решение:

SELECT Maker , count(distinct model) Qty FROM Product
GROUP BY maker
HAVING count(distinct model) > = ALL
(SELECT count(distinct model) FROM Product
GROUP BY maker)
or
count(distinct model) <= ALL
(SELECT count(distinct model) FROM Product
GROUP BY maker)

90
Вывести все строки из таблицы Product, кроме трех строк с наименьшими номерами моделей и трех строк с наибольшими номерами моделей. Решение:

SELECT t1.maker, t1.model, t1.type
FROM(
SELECT
row_number() over (order by model) p1,
row_number() over (order by model DESC) p2,
*
FROM product
) t1
WHERE p1 > 3 AND p2 > 3

91
C точностью до двух десятичных знаков определить среднее количество краски на квадрате. Решение:

SELECT count(maker)
FROM product
WHERE maker in
(
  SELECT maker FROM product
  GROUP BY maker
  HAVING count(model) = 1
)

92
Выбрать все белые квадраты, которые окрашивались только из баллончиков, пустых к настоящему времени. Вывести имя квадрата Решение:

SELECT Q_NAME
FROM utQ
WHERE Q_ID IN (SELECT DISTINCT B.B_Q_ID
FROM (SELECT B_Q_ID
FROM utB
GROUP BY B_Q_ID
HAVING SUM(B_VOL) = 765) AS B
WHERE B.B_Q_ID NOT IN (SELECT B_Q_ID
FROM utB
WHERE B_V_ID IN (SELECT B_V_ID
FROM utB
GROUP BY B_V_ID
HAVING SUM(B_VOL) < 255)))

93
Для каждой компании, перевозившей пассажиров, подсчитать время, которое провели в полете самолеты с пассажирами. Вывод: название компании, время в минутах. Решение:

 select c.name, sum(vr.vr)
from
(select distinct t.id_comp, pt.trip_no, pt.date,t.time_out,t.time_in,--pt.id_psg,
case
     when DATEDIFF(mi, t.time_out,t.time_in)> 0 then DATEDIFF(mi, t.time_out,t.time_in)
     when DATEDIFF(mi, t.time_out,t.time_in)<=0 then DATEDIFF(mi, t.time_out,t.time_in+1)
end vr
from pass_in_trip pt left join trip t on pt.trip_no=t.trip_no
) vr left join company c on vr.id_comp=c.id_comp
group by c.name;

94
Для семи последовательных дней, начиная от минимальной даты, когда из Ростова было совершено максимальное число рейсов, определить число рейсов из Ростова. Вывод: дата, количество рейсов Решение:

SELECT DATEADD(day, S.Num, D.date) AS Dt,
(SELECT COUNT(DISTINCT P.trip_no)
FROM Pass_in_trip P
JOIN Trip T
ON P.trip_no = T.trip_no
AND T.town_from = 'Rostov'
AND P.date = DATEADD(day, S.Num, D.date)) AS Qty
FROM (SELECT (3 * ( x - 1 ) + y - 1) AS Num
FROM (SELECT 1 AS x UNION ALL SELECT 2 UNION ALL SELECT 3) AS N1
CROSS JOIN (SELECT 1 AS y UNION ALL SELECT 2 UNION ALL SELECT 3) AS N2
WHERE (3 * ( x - 1 ) + y ) < 8) AS S,
(SELECT MIN(A.date) AS date
FROM (SELECT P.date,
COUNT(DISTINCT P.trip_no) AS Qty,
MAX(COUNT(DISTINCT P.trip_no)) OVER() AS M_Qty
FROM Pass_in_trip AS P
JOIN Trip AS T
ON P.trip_no = T.trip_no
AND T.town_from = 'Rostov'
GROUP BY P.date) AS A
WHERE A.Qty = A.M_Qty) AS D

95
На основании информации из таблицы Pass_in_Trip, для каждой авиакомпании определить: 1) количество выполненных перелетов; 2) число использованных типов самолетов; 3) количество перевезенных различных пассажиров; 4) общее число перевезенных компанией пассажиров. Вывод: Название компании, 1), 2), 3), 4).


SELECT name,
COUNT(DISTINCT CONVERT(CHAR(24),date)+CONVERT(CHAR(4),Trip.trip_no)),
COUNT(DISTINCT plane),
COUNT(DISTINCT ID_psg),
COUNT(*)
FROM Company,Pass_in_trip,Trip
WHERE Company.ID_comp=Trip.ID_comp and Trip.trip_no=Pass_in_trip.trip_no
GROUP BY Company.ID_comp,name

96
При условии, что баллончики с красной краской использовались более одного раза, выбрать из них такие, которыми окрашены квадраты, имеющие голубую компоненту. Вывести название баллончика


with r as (select v.v_name,
v.v_id,
count(case when v_color = 'R' then 1 end) over(partition by v_id) cnt_r,
count(case when v_color = 'B' then 1 end) over(partition by b_q_id) cnt_b
FROM utV v join utB b on v.v_id = b.b_v_id)
SELECT v_name
FROM r
WHERE cnt_r > 1 AND cnt_b > 0
GROUP BY v_name

97
Отобрать из таблицы Laptop те строки, для которых выполняется следующее условие: значения из столбцов speed, ram, price, screen возможно расположить таким образом, что каждое последующее значение будет превосходить предыдущее в 2 раза или более. Замечание: все известные характеристики ноутбуков больше нуля. Вывод: code, speed, ram, price, screen.

SELECT code, speed, ram, price, screen
FROM laptop WHERE exists (
SELECT 1 x
FROM (
SELECT v, rank()over(order by v) rn
FROM( select cast(speed as float) sp, cast(ram as float) rm,
CAST(price as float) pr, cast(screen as float) sc
)l unpivot(v for c in (sp, rm, pr, sc))u
)l pivot(max(v) for rn in ([1],[2],[3],[4]))p
WHERE [1]*2 <= [2] and [2]*2 <= [3] AND [3]*2 <= [4]
)

98
Вывести список ПК, для каждого из которых результат побитовой операции ИЛИ, примененной к двоичным представлениям скорости процессора и объема памяти, содержит последовательность из не менее четырех идущих подряд единичных битов. Вывод: код модели, скорость процессора, объем памяти.


with CTE AS
(SELECT
1 n, cast (0 as varchar(16)) bit_or,
code, speed, ram FROM PC
UNION ALL
SELECT n*2,
cast (convert(bit,(speed|ram)&n) as varchar(1))+cast(bit_or as varchar(15))
, code, speed, ram
FROM CTE WHERE n < 65536
)
SELECT code, speed, ram FROM CTE
WHERE n = 65536 AND CHARINDEX('1111', bit_or )> 0

99
Рассматриваются только таблицы Income_o и Outcome_o. Известно, что прихода/расхода денег в воскресенье не бывает. Для каждой даты прихода денег на каждом из пунктов определить дату инкассации по следующим правилам: 1. Дата инкассации совпадает с датой прихода, если в таблице Outcome_o нет записи о выдаче денег в эту дату на этом пункте. 2. В противном случае - первая возможная дата после даты прихода денег, которая не является воскресеньем и в Outcome_o не отмечена выдача денег сдатчикам вторсырья в эту дату на этом пункте. Вывод: пункт, дата прихода денег, дата инкассации.


SELECT point,"date" income_date,"date" + nvl (min(case when diff > cnt then cnt else null end), max(cnt)+1
) incass_date
FROM (SELECT i.point, i."date", (trunc(o."date") - trunc(i."date")) diff,
count(1) over (partition by i.point, i."date" order by o."date" rows between unbounded preceding and current row)-1 cnt
FROM income_o i
JOIN (select point, "date", 1 disabled FROM outcome_o
UNION
SELECT point, trunc("date"+7,'DAY'), 1 disabled FROM income_o) o
ON i.point = o.point
WHERE o."date" > = i."date")
GROUP BY point, "date"

100
Написать запрос, который выводит все операции прихода и расхода из таблиц Income и Outcome в следующем виде: дата, порядковый номер записи за эту дату, пункт прихода, сумма прихода, пункт расхода, сумма расхода. При этом все операции прихода по всем пунктам, совершённые в течение одного дня, упорядочены по полю code, и так же все операции расхода упорядочены по полю code. В случае, если операций прихода/расхода за один день было не равное количество, выводить NULL в соответствующих колонках на месте недостающих операций.

SELECT DISTINCT A.date , A.R, B.point, B.inc, C.point, C.out
FROM (Select distinct date, ROW_Number() OVER(PARTITION BY date ORDER BY code asc) as R FROM Income
UNION
SELECT DISTINCT date, ROW_Number() OVER(PARTITION BY date ORDER BY code asc) FROM Outcome) A
LEFT JOIN (Select date, point, inc
, ROW_Number() OVER(PARTITION BY date ORDER BY code asc) as RI FROM Income
) B ON B.date=A.date and B.RI=A.R
LEFT JOIN (Select date, point, out
, ROW_Number() OVER(PARTITION BY date ORDER BY code asc) as RO FROM Outcome
) C ON C.date=A.date AND C.RO=A.R;
